package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/moio/booster/api"
	"github.com/moio/booster/cmd"

	"github.com/pkg/errors"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/urfave/cli/v2"
)

// set by goreleaser via -ldflags at build time
// see https://golang.org/cmd/link/, https://goreleaser.com/customization/build/
// Empty string means snapshot build
var version string

func main() {
	// init logging
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix

	// init command line handler
	app := cli.NewApp()
	app.Name = "booster"
	app.Usage = "Synchronizes container image registries efficiently"
	if version != "" {
		app.Version = version
	} else {
		app.Version = "snapshot"
	}
	app.EnableBashCompletion = true
	app.Commands = []*cli.Command{
		{
			Name:   "serve",
			Usage:  "serves the booster HTTP API",
			Action: serve,
			Flags: []cli.Flag{
				&cli.IntFlag{
					Name:  "port",
					Usage: "TCP port for the API (default 5000)",
					Value: 5000,
				},
				&cli.StringFlag{
					Name:  "path",
					Usage: "path of the base registry directory (default /var/lib/registry)",
					Value: "/var/lib/registry",
				},
				&cli.StringFlag{
					Name:  "primary",
					Usage: "http address of the primary, if any",
					Value: "",
				},
			},
		},
		{
			Name:      "diff",
			Usage:     "generates a patch between sets of images",
			ArgsUsage: "OLD_LIST_FILE NEW_LIST_FILE",
			Action:    diff,
			Flags: []cli.Flag{
				&cli.StringFlag{
					Name:  "path",
					Usage: "temporary path for images",
					Value: "tmp",
				},
				&cli.StringFlag{
					Name:  "output",
					Usage: "where to save the patch (default: autogenerated)",
					Value: "",
				},
			},
		},
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal().Err(err).Send()
	}
}

func serve(ctx *cli.Context) error {
	path := ctx.String("path")
	info, err := os.Stat(path)
	if err != nil {
		return err
	}
	if !info.IsDir() {
		return errors.Errorf("%v is not a directory", path)
	}

	return api.Serve(path, ctx.Int("port"), ctx.String("primary"))
}

func diff(ctx *cli.Context) error {
	if ctx.Args().Len() != 2 {
		cli.ShowSubcommandHelpAndExit(ctx, 1)
	}
	oldPath := ctx.Args().Get(0)
	newPath := ctx.Args().Get(1)

	tempDir := ctx.String("path")
	info, err := os.Stat(tempDir)
	if err != nil {
		return err
	}
	if !info.IsDir() {
		return errors.Errorf("%v is not a directory", tempDir)
	}

	tempDir, err = filepath.EvalSymlinks(tempDir)
	if err != nil {
		return errors.Wrapf(err, "Could not evaluate symlinks for %v", tempDir)
	}

	output := ctx.String("output")
	if output == "" {
		// autogenerate
		o := strings.TrimSuffix(filepath.Base(oldPath), filepath.Ext(oldPath))
		n := strings.TrimSuffix(filepath.Base(newPath), filepath.Ext(newPath))
		output = fmt.Sprintf("%v-%v", o, n)
	}

	return cmd.Diff(oldPath, newPath, tempDir, output)
}
}
